---
sidebar_position: 1
---

# Intro

For every incoming HTTP request, the library takes its URL. It then attempts to match this URL
with a corresponding file in your application. This route matching system creates
a simple and intuitive method of routing your application's URLs based on your file and folder structure.

For instance, on request with url `/users/123/orders/456` the `/users/[productId]/orders/[orderId].js`
will be invoked.

:::tip Great news!

It works with any popular file extentions: ts, js, cjs, and mjs.

:::

Use functions or objects with methods in the target files. And default export them.

## Function

The function will be invoked on any request method: get, post, patch, etc.

```js
export default function(req, res, routeParams) {
  // Take dynamic route params from the last argument
}
```

:::tip Note

Anything what goes in useFileRouter won't be mutated. Route params are passed always as the last argument.
For instance, for Express.js it will be: `function(req, res, next, routeParams)`.

:::

Get the route params from dynamic paths in the last argument. For instance,
in this file `/users/[productId]/orders/[orderId].js` these params are available:
`{ productId, orderId }`. More details are described on the [route matching part](/docs/category/route-matching).

## Object with methods

Using object, you can specify functions for each method type. The rules are identical. The main difference only in
method's routing. Not listed method function will lead to the 404 error.

```js
export default {
  get(req, res, routeParams) {
    const { documentId, draftId } = routeParams;
    res.end(`Requested document ${documentId} and his draft ${draftId}`);
  },
  post(req, res, routeParams) {
    const { documentId, draftId } = routeParams;
    res.end(`Created draft ${draftId} for document ${documentId}`);
  },
  patch(req, res, routeParams) {
  },
}
```
